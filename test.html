<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Medivox HDL</title>
  <script src="https://unpkg.com/wavesurfer.js@7"></script>
  <style>
    :root {
      --bg-color: #1e1e1e;
      --container-bg: #2d2d2d;
      --text-color: #ffffff;
      --primary-color: #4a9eff;
      --secondary-color: #252525;
      --tertiary-color: #353535;
      --success-color: #4caf50;
      --error-color: #ff4444;
      --warning-color: #ffa500;
      --disabled-color: #666666;
      --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
    }

    * {
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: var(--font-family);
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .main-container { width: 100%; max-width: 900px; background-color: var(--bg-color); padding: 20px; border-radius: 8px; }
    h1 { font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 20px; }

    .status-bar { background-color: var(--secondary-color); padding: 10px; border-radius: 4px; margin-bottom: 20px; text-align: right; display: flex; justify-content: space-between; align-items: center; }
    #connectionStatus { font-weight: bold; color: var(--error-color); }
    #connectionStatus::before { content: "●"; margin-right: 8px; }

    .error-message { background-color: rgba(255, 68, 68, 0.1); border: 1px solid var(--error-color); color: var(--error-color); padding: 8px 12px; border-radius: 4px; font-size: 12px; display: none; }

    /* Tabs */
    .tabs { display: flex; margin-bottom: -2px; z-index: 1; position: relative; }
    .tab-button { padding: 10px 20px; cursor: pointer; background-color: var(--secondary-color); border: 2px solid var(--tertiary-color); border-bottom: none; border-radius: 8px 8px 0 0; margin-right: 5px; color: #ccc; touch-action: manipulation; }
    .tab-button.active { background-color: var(--container-bg); border-color: var(--tertiary-color); color: var(--primary-color); font-weight: bold; }
    .tab-content { background-color: var(--container-bg); padding: 40px 20px; text-align: center; border-radius: 8px; border-top-left-radius: 0; min-height: 200px; display: flex; flex-direction: column; justify-content: center; align-items: center; border: 2px solid var(--tertiary-color); margin-bottom: 20px; }
    .tab-pane { display: none; }
    .tab-pane.active { display: block; }

    /* Upload */
    #dropzone { width: 100%; transition: border-color 0.3s; padding: 0; border: 2px dashed var(--tertiary-color); border-radius: 8px; box-sizing: border-box; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 200px; }
    #dropzone.dragover { border-color: var(--primary-color); background-color: var(--secondary-color); }
    #dropzone-icon { font-size: 48px; }
    #dropzone-text { font-size: 16px; color: #ccc; margin: 10px 0; }
    #browseBtn { background-color: var(--primary-color); color: white; padding: 10px 20px; font-size: 14px; border: none; border-radius: 4px; cursor: pointer; touch-action: manipulation; }
    #fileLabel { margin-top: 15px; font-style: italic; color: var(--primary-color); }

    /* Recorder */
    #recorder-tab-content { gap: 15px; }
    #waveform { width: 100%; height: 128px; }
    #controls-timeline, #main-controls, #edit-controls { display: flex; justify-content: center; align-items: center; gap: 15px; width: 100%; flex-wrap: wrap; }
    #main-controls button, #edit-controls button { padding: 10px 15px; border-radius: 50px; border: none; cursor: pointer; font-size: 16px; background: var(--tertiary-color); color: white; min-width: 50px; touch-action: manipulation; -webkit-user-select: none; user-select: none; }
    #main-controls button:hover:not(:disabled), #edit-controls button:hover:not(:disabled) { background: var(--primary-color); transform: scale(1.05); transition: all 0.2s ease; }
    #main-controls button:active:not(:disabled), #edit-controls button:active:not(:disabled) { transform: scale(0.95); }
    #main-controls button:disabled, #edit-controls button:disabled { opacity: 0.5; cursor: not-allowed; }
    #deleteBtn { background-color: var(--error-color); }
    #deleteBtn:hover:not(:disabled) { background-color: #ff6666; }
    #main-controls #recordBtn { background-color: var(--error-color); width: 60px; height: 60px; font-size: 24px; }
    #main-controls #recordBtn.recording { background-color: #ff8c00; }
    #main-controls #stopBtn { background-color: var(--secondary-color); width: 60px; height: 60px; font-size: 24px; }

    #timeline { font-family: "Courier New", Courier, monospace; font-size: 18px; color: var(--primary-color); }

    .edit-mode-toggle { display: flex; background-color: var(--secondary-color); border-radius: 20px; padding: 4px; user-select: none; -webkit-user-select: none; }
    .edit-mode-toggle button { background: transparent; border: none; padding: 6px 15px; border-radius: 16px; color: #ccc; cursor: pointer; touch-action: manipulation; transition: all 0.2s ease; }
    .edit-mode-toggle button:hover { background-color: rgba(74, 158, 255, 0.2); }
    .edit-mode-toggle button.active { background-color: var(--primary-color); color: white; pointer-events: none; }

    /* Voice progress */
    .voice-progress-container { width: 100%; margin: 15px 0; padding: 10px 0; position: relative; }
    .voice-progress-bar { width: 100%; height: 8px; background-color: var(--tertiary-color); border-radius: 4px; position: relative; cursor: pointer; overflow: visible; }
    .voice-progress-fill { height: 100%; background-color: var(--primary-color); border-radius: 4px; width: 0%; transition: width 0.1s linear; pointer-events: none; }
    .voice-progress-handle { width: 20px; height: 20px; background-color: var(--primary-color); border: 3px solid white; border-radius: 50%; position: absolute; top: 50%; transform: translate(-50%, -50%); cursor: grab; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 10; left: 0%; touch-action: none; }
    .voice-progress-handle:active, .voice-progress-handle.dragging { cursor: grabbing; transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 3px 6px rgba(0,0,0,0.5); }
    .voice-time-labels { display: flex; justify-content: space-between; margin-top: 5px; font-size: 12px; color: var(--primary-color); font-family: "Courier New", monospace; }

    /* Actions/Result */
    .actions-bar, .result-header, .result-actions { display: flex; align-items: center; padding: 10px; border-radius: 4px; margin-bottom: 20px; }
    .actions-bar { background-color: var(--bg-color); justify-content: flex-start; flex-wrap: wrap; gap: 10px; }
    label { margin-right: 10px; }
    select { background-color: var(--tertiary-color); color: var(--text-color); border: 1px solid var(--tertiary-color); padding: 8px 10px; border-radius: 4px; font-size: 14px; }
    #processBtn { background-color: var(--primary-color); color: white; padding: 12px 30px; font-size: 16px; border: none; border-radius: 4px; cursor: pointer; touch-action: manipulation; }
    #processBtn:disabled { background-color: var(--disabled-color); cursor: not-allowed; }
    #progressLabel { margin-left: 20px; font-size: 14px; color: var(--primary-color); display: none; }

    .result-section { display: none; }
    .result-header { justify-content: space-between; }
    .result-header h2 { font-size: 18px; font-weight: bold; color: var(--success-color); margin: 0; }
    #newSessionBtn, #copyBtn, #saveBtn { border: none; border-radius: 4px; font-weight: bold; cursor: pointer; transition: background-color 0.3s; color: white; padding: 8px 15px; touch-action: manipulation; }
    #newSessionBtn { background-color: var(--container-bg); }
    #copyBtn { background-color: var(--success-color); }
    #saveBtn { background-color: #2196f3; }

    #resultText { width: 100%; max-height: 70vh; overflow-y: auto; background-color: var(--container-bg); color: var(--text-color); border: 1px solid var(--primary-color); border-radius: 4px; padding: 15px; box-sizing: border-box; text-align: left; font-family: Arial, sans-serif; font-size: 11pt; line-height: 1.5; -webkit-overflow-scrolling: touch; }
    #resultText span[style*="font-weight:bold"] { font-weight: bold !important; }

    /* Mobile */
    @media (max-width: 600px) {
      .main-container { padding: 10px; }
      h1 { font-size: 20px; }
      .tab-button { padding: 8px 12px; font-size: 14px; }
      #main-controls button, #edit-controls button { padding: 8px 12px; font-size: 14px; }
      #main-controls #recordBtn, #main-controls #stopBtn { width: 50px; height: 50px; font-size: 20px; }
      #timeline { font-size: 14px; }
      .voice-progress-handle { width: 24px; height: 24px; }
    }

    @supports (-webkit-touch-callout: none) {
      input[type="file"] { font-size: 16px; }
      button { -webkit-appearance: none; appearance: none; }
      .voice-progress-bar { -webkit-user-select: none; user-select: none; }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <h1>Medivox HDL</h1>
    <div class="status-bar">
      <div class="error-message" id="errorMessage"></div>
      <div id="connectionStatus">Déconnecté</div>
    </div>

    <div id="processing-container">
      <div class="tabs">
        <button class="tab-button active" data-tab="upload-tab">Téléverser un fichier</button>
        <button class="tab-button" data-tab="recorder-tab">Enregistrer un Audio</button>
      </div>

      <div id="upload-tab" class="tab-pane active">
        <div class="tab-content">
          <div id="dropzone">
            <div id="dropzone-icon">📁</div>
            <div id="dropzone-text">Glissez-déposez votre fichier audio ici, ou cliquez sur Parcourir</div>
            <input type="file" id="fileInput" accept="audio/*" hidden />
            <button id="browseBtn">Parcourir</button>
            <div id="fileLabel"></div>
          </div>
        </div>
      </div>

      <div id="recorder-tab" class="tab-pane">
        <div class="tab-content" id="recorder-tab-content">
          <div id="waveform"></div>

          <div class="voice-progress-container">
            <div class="voice-progress-bar" id="voiceProgressBar">
              <div class="voice-progress-fill" id="voiceProgressFill"></div>
              <div class="voice-progress-handle" id="voiceProgressHandle"></div>
            </div>
            <div class="voice-time-labels">
              <span id="currentTimeLabel">00:00.0</span>
              <span id="totalTimeLabel">00:00.0</span>
            </div>
          </div>

          <div id="controls-timeline">
            <span id="timeline">00:00.0 / 00:00.0</span>
          </div>
          <div id="edit-controls">
            <button id="playBtn">▶️ Play</button>
            <button id="rewindBtn">⏪ 3s</button>
            <button id="forwardBtn">3s ⏩</button>
            <button id="deleteBtn">🗑️ Effacer</button>
            <div class="edit-mode-toggle">
              <button id="insertModeBtn" class="active" title="Insérer du nouvel audio à la position du curseur">Insérer</button>
              <button id="overwriteModeBtn" title="Écraser l'audio existant depuis la position du curseur">Écraser</button>
            </div>
          </div>
          <div id="main-controls">
            <button id="recordBtn" title="Enregistrer/Pause">🎤</button>
            <button id="stopBtn" title="Arrêter">⏹️</button>
          </div>
        </div>
      </div>

      <div class="actions-bar">
        <div>
          <label for="templateSelect">Modèle :</label>
          <select id="templateSelect">
            <option value="Standard">Standard</option>
          </select>
        </div>
        <button id="processBtn" disabled>Transcrire et Formater</button>
        <div id="progressLabel"></div>
      </div>
    </div>

    <div id="resultSection" class="result-section">
      <div class="result-header">
        <h2>✅ Rapport Prêt</h2>
        <button id="newSessionBtn">Nouvelle Session</button>
      </div>
      <div id="resultText"></div>
      <div class="result-actions">
        <button id="copyBtn">Copier le Rapport</button>
        <button id="saveBtn">Enregistrer dans un Fichier</button>
      </div>
    </div>
  </div>

  <audio id="click-sound" src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA" preload="auto"></audio>
  <audio id="start-sound" src="data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAACA" preload="auto"></audio>
  <audio id="stop-sound" src="data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAAE" preload="auto"></audio>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // --- Config ---
      const CONFIG = {
        SERVER_ADDRESS: "my-radiology-server.medivox.ca",
        RECONNECT_DELAY: 5000,
        MAX_RECONNECT_ATTEMPTS: 5,
        AUDIO_CONSTRAINTS: { sampleRate: 8000, channels: 1, bitDepth: 16 },
        SUPPORTED_AUDIO_TYPES: ["audio/wav", "audio/mp3", "audio/mpeg", "audio/m4a", "audio/x-m4a", "audio/ogg", "audio/webm"],
        MAX_FILE_SIZE: 50 * 1024 * 1024,
      };

      const ERROR_TYPES = { CONNECTION: "connection", AUDIO: "audio", FILE: "file", PROCESSING: "processing", PERMISSION: "permission" };

      // --- Global state ---
      let socket = null;
      let currentFile = null;
      let transcribedText = "";
      let reconnectAttempts = 0;

      // Recording/Playback state
      let wavesurfer, mediaRecorder, stream;
      let audioChunks = [];
      let isRecording = false;
      let isPaused = false;
      let editMode = "insert";
      let originalBuffer = null;
      let isDraggingProgress = false;
      let animationFrameId = null;
      let recordStartMs = null; // start timestamp
      let recordElapsedTimer = null; // interval id

      // --- UI Elements ---
      const connectionStatus = document.getElementById("connectionStatus");
      const errorMessage = document.getElementById("errorMessage");
      const processBtn = document.getElementById("processBtn");
      const progressLabel = document.getElementById("progressLabel");
      const processingContainer = document.getElementById("processing-container");
      const resultSection = document.getElementById("resultSection");
      const resultText = document.getElementById("resultText");
      const newSessionBtn = document.getElementById("newSessionBtn");
      const copyBtn = document.getElementById("copyBtn");
      const saveBtn = document.getElementById("saveBtn");

      const dropzone = document.getElementById("dropzone");
      const fileInput = document.getElementById("fileInput");
      const browseBtn = document.getElementById("browseBtn");
      const fileLabel = document.getElementById("fileLabel");

      const recordBtn = document.getElementById("recordBtn");
      const stopBtn = document.getElementById("stopBtn");
      const playBtn = document.getElementById("playBtn");
      const rewindBtn = document.getElementById("rewindBtn");
      const forwardBtn = document.getElementById("forwardBtn");
      const deleteBtn = document.getElementById("deleteBtn");
      const insertModeBtn = document.getElementById("insertModeBtn");
      const overwriteModeBtn = document.getElementById("overwriteModeBtn");
      const timeline = document.getElementById("timeline");

      const voiceProgressBar = document.getElementById("voiceProgressBar");
      const voiceProgressFill = document.getElementById("voiceProgressFill");
      const voiceProgressHandle = document.getElementById("voiceProgressHandle");
      const currentTimeLabel = document.getElementById("currentTimeLabel");
      const totalTimeLabel = document.getElementById("totalTimeLabel");

      const clickSound = document.getElementById("click-sound");
      const startSound = document.getElementById("start-sound");
      const stopSound = document.getElementById("stop-sound");

      // Browser detection
      const userAgent = navigator.userAgent.toLowerCase();
      const isIOS = /ipad|iphone|ipod/.test(userAgent) && !window.MSStream;
      const isIOSSafari = isIOS && /version/.test(userAgent) && !/(chrome|crios|fxios|opera|edgios)/i.test(userAgent);
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const isAndroid = /android/i.test(userAgent);
      const isMobile = isIOS || isAndroid || /mobile/i.test(userAgent);

      // Init
      initializeApplication();

      function initializeApplication() {
        try {
          if (isIOS || isSafari) initializeIOSCompatibility();
          initializeWavesurfer();
          connectWebSocket();
          setupEventListeners();
          updateRecorderUI();
          initializeProgressBar();
        } catch (error) {
          handleError(ERROR_TYPES.PROCESSING, "Failed to initialize application", error);
        }
      }

      function initializeIOSCompatibility() {
        const AudioContextCls = window.AudioContext || window.webkitAudioContext;
        if (AudioContextCls) {
          const audioContext = new AudioContextCls();
          const resume = () => {
            if (audioContext.state === "suspended") audioContext.resume().catch(() => {});
          };
          ["touchstart", "touchend", "mousedown", "click"].forEach((ev) => document.addEventListener(ev, resume, { once: true, passive: true }));
        }

        let lastTouchEnd = 0;
        document.addEventListener(
          "touchend",
          (e) => {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) e.preventDefault();
            lastTouchEnd = now;
          },
          { passive: false }
        );

        if (isIOS && window.location.protocol !== "https:" && window.location.hostname !== "localhost") {
          showErrorMessage("HTTPS requis pour l'enregistrement audio sur iOS", "warning");
        }
      }

      // Progress Bar logic
      function initializeProgressBar() {
        voiceProgressBar.addEventListener("mousedown", handleProgressBarClick);
        voiceProgressHandle.addEventListener("mousedown", handleProgressDragStart);
        document.addEventListener("mousemove", handleProgressDragMove);
        document.addEventListener("mouseup", handleProgressDragEnd);

        voiceProgressBar.addEventListener("touchstart", handleProgressBarClick, { passive: false });
        voiceProgressHandle.addEventListener("touchstart", handleProgressDragStart, { passive: false });
        document.addEventListener("touchmove", handleProgressDragMove, { passive: false });
        document.addEventListener("touchend", handleProgressDragEnd, { passive: false });

        voiceProgressHandle.addEventListener("selectstart", (e) => e.preventDefault());
      }

      function getClientX(e) {
        return e.type && e.type.includes("touch") ? (e.touches[0] ? e.touches[0].clientX : e.changedTouches[0].clientX) : e.clientX;
      }

      function handleProgressBarClick(e) {
        if (isDraggingProgress) return;
        e.preventDefault();
        const rect = voiceProgressBar.getBoundingClientRect();
        const clientX = getClientX(e);
        const pct = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
        if (wavesurfer && wavesurfer.getDuration() > 0) {
          const newTime = (pct / 100) * wavesurfer.getDuration();
          wavesurfer.seekTo(pct / 100);
          updateProgressBar(newTime, wavesurfer.getDuration());
        }
      }
      function handleProgressDragStart(e) {
        e.preventDefault();
        e.stopPropagation();
        isDraggingProgress = true;
        voiceProgressHandle.classList.add("dragging");
        if (wavesurfer && wavesurfer.isPlaying()) wavesurfer.pause();
      }
      function handleProgressDragMove(e) {
        if (!isDraggingProgress) return;
        e.preventDefault();
        const rect = voiceProgressBar.getBoundingClientRect();
        const clientX = getClientX(e);
        const pct = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
        if (wavesurfer && wavesurfer.getDuration() > 0) {
          const newTime = (pct / 100) * wavesurfer.getDuration();
          updateProgressBar(newTime, wavesurfer.getDuration());
          wavesurfer.seekTo(pct / 100);
        }
      }
      function handleProgressDragEnd(e) {
        if (!isDraggingProgress) return;
        e.preventDefault();
        isDraggingProgress = false;
        voiceProgressHandle.classList.remove("dragging");
      }

      function updateProgressBar(currentTime, duration) {
        if (!duration || isNaN(duration)) duration = 0;
        if (!currentTime || isNaN(currentTime)) currentTime = 0;
        const pct = duration > 0 ? (currentTime / duration) * 100 : 0;
        voiceProgressFill.style.width = `${pct}%`;
        voiceProgressHandle.style.left = `${pct}%`;
        currentTimeLabel.textContent = formatTime(currentTime);
        totalTimeLabel.textContent = formatTime(duration);
        updateTimeline(currentTime, duration);
      }

      function startProgressAnimation() {
        const tick = () => {
          if (wavesurfer && wavesurfer.isPlaying()) {
            updateProgressBar(wavesurfer.getCurrentTime(), wavesurfer.getDuration());
            animationFrameId = requestAnimationFrame(tick);
          }
        };
        tick();
      }
      function stopProgressAnimation() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

      // --- Robust Errors ---
      function handleError(type, message, error = null) {
        console.error(`[${type.toUpperCase()}] ${message}:`, error);
        let userMessage = message; let severity = "error";
        if (type === ERROR_TYPES.CONNECTION) { userMessage = getConnectionErrorMessage(error); severity = reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS ? "warning" : "error"; }
        if (type === ERROR_TYPES.AUDIO) userMessage = getAudioErrorMessage(error);
        if (type === ERROR_TYPES.FILE) userMessage = getFileErrorMessage(error);
        if (type === ERROR_TYPES.PERMISSION) userMessage = "Permissions requises non accordées. Veuillez autoriser l'accès au microphone.";
        if (type === ERROR_TYPES.PROCESSING) userMessage = userMessage || "Erreur de traitement. Veuillez réessayer.";
        showErrorMessage(userMessage, severity);
        if (type === ERROR_TYPES.CONNECTION && reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS) setTimeout(() => connectWebSocket(), CONFIG.RECONNECT_DELAY);
      }
      function getConnectionErrorMessage(error) {
        if (!error) return "Erreur de connexion inconnue";
        const map = { 1006: "Connexion fermée de manière inattendue", 1011: "Erreur serveur interne", 1012: "Service en cours de redémarrage" };
        return map[error.code] || `Erreur de connexion: ${error.message || "Code " + error.code}`;
      }
      function getAudioErrorMessage(error) {
        if (!error) return "Erreur audio inconnue";
        const map = { NotAllowedError: "Permission d'accès au microphone refusée", NotFoundError: "Aucun microphone détecté", NotReadableError: "Microphone en cours d'utilisation par une autre application", OverconstrainedError: "Paramètres audio non supportés", SecurityError: "Accès microphone bloqué (HTTPS requis)", AbortError: "Opération audio interrompue", InvalidStateError: "État audio invalide" };
        return map[error.name] || `Erreur audio: ${error.message}`;
      }
      function getFileErrorMessage(error) {
        if (!error) return "Erreur de fichier inconnue";
        if (error.type === "size") return `Fichier trop volumineux (max ${CONFIG.MAX_FILE_SIZE / (1024 * 1024)}MB)`;
        if (error.type === "format") return "Format de fichier non supporté";
        return `Erreur de fichier: ${error.message}`;
      }
      function showErrorMessage(message, severity = "error") {
        errorMessage.textContent = message; errorMessage.className = `error-message ${severity}`; errorMessage.style.display = "block";
        if (severity === "warning") setTimeout(hideErrorMessage, 10000);
      }
      function hideErrorMessage() { errorMessage.style.display = "none"; }

      // --- WebSocket ---
      function connectWebSocket() {
        if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) return;
        const url = `wss://${CONFIG.SERVER_ADDRESS}`;
        connectionStatus.textContent = "Connexion..."; connectionStatus.style.color = "var(--warning-color)";
        try { socket = new WebSocket(url); setupWebSocketHandlers(); } catch (e) { handleError(ERROR_TYPES.CONNECTION, "Failed to create WebSocket connection", e); reconnectAttempts++; }
      }
      function setupWebSocketHandlers() {
        socket.onopen = () => { reconnectAttempts = 0; updateUIForConnection(true); hideErrorMessage(); showProgress("Connecté au serveur de transcription."); setTimeout(hideProgress, 3000); };
        socket.onmessage = (event) => {
          try { const data = JSON.parse(event.data); handleServerMessage(data); } catch (e) { handleError(ERROR_TYPES.PROCESSING, "Invalid server response", e); }
        };
        socket.onerror = (err) => { handleError(ERROR_TYPES.CONNECTION, "WebSocket error occurred", err); updateUIForConnection(false); };
        socket.onclose = (event) => { socket = null; updateUIForConnection(false); if (!event.wasClean) { reconnectAttempts++; handleError(ERROR_TYPES.CONNECTION, "Connection lost", { code: event.code, message: event.reason }); } };
      }
      function handleServerMessage(data) {
        const { action, message, text, performance, error: serverError } = data;
        try {
          switch (action) {
            case "progress":
              showProgress(message);
              break;
            case "transcription_complete":
              if (!text) throw new Error("No transcription text received");
              transcribedText = text;
              const speed = performance ? `(${performance.speed || "N/A"})` : "";
              showProgress(`Transcription terminée ${speed}. Mise en forme en cours...`);
              requestFormatting();
              break;
            case "formatting_complete":
              if (!text) throw new Error("No formatted text received");
              hideProgress();
              resultText.innerHTML = formatTextAsHtml(text);
              processBtn.disabled = false; processBtn.textContent = "Transcrire et Formater";
              toggleSections(true);
              break;
            case "error":
              throw new Error(message || serverError || "Unknown server error");
            default:
              console.warn("Unknown server action:", action);
          }
        } catch (e) {
          handleError(ERROR_TYPES.PROCESSING, "Server message processing failed", e);
          resetUIafterProcessing();
        }
      }
      function requestFormatting() {
        if (!socket || socket.readyState !== WebSocket.OPEN) throw new Error("WebSocket not connected");
        if (!transcribedText) throw new Error("No transcribed text to format");
        try { socket.send(JSON.stringify({ action: "format_text", text: transcribedText })); } catch (e) { handleError(ERROR_TYPES.CONNECTION, "Failed to send formatting request", e); }
      }

      // --- UI state ---
      function updateUIForConnection(isConnected) { connectionStatus.textContent = isConnected ? "Connecté" : "Déconnecté"; connectionStatus.style.color = isConnected ? "var(--success-color)" : "var(--error-color)"; updateProcessButtonState(); }
      function updateProcessButtonState() { const isConnected = socket && socket.readyState === WebSocket.OPEN; processBtn.disabled = !isConnected || !currentFile; }
      function showProgress(message) { progressLabel.textContent = message; progressLabel.style.display = "block"; }
      function hideProgress() { progressLabel.style.display = "none"; }
      function toggleSections(showResult) { resultSection.style.display = showResult ? "block" : "none"; processingContainer.style.display = showResult ? "none" : "block"; }
      function resetToStart() { toggleSections(false); currentFile = null; transcribedText = ""; fileLabel.textContent = ""; resultText.innerHTML = ""; fileInput.value = ""; resetRecorderState(); updateProcessButtonState(); }
      function resetRecorderState() { if (wavesurfer) wavesurfer.empty(); originalBuffer = null; stopRecordingTimer(); updateProgressBar(0, 0); updateTimeline(0, 0); updateRecorderUI(); }

      // --- Files ---
      function validateFile(file) {
        if (!file) throw { type: "format", message: "No file provided" };
        if (file.size > CONFIG.MAX_FILE_SIZE) throw { type: "size", message: `File size (${Math.round(file.size / (1024 * 1024))}MB) exceeds limit` };
        const name = (file.name || "").toLowerCase();
        const ok = CONFIG.SUPPORTED_AUDIO_TYPES.some((type) => file.type === type) || [".wav", ".mp3", ".m4a", ".ogg", ".webm"].some((ext) => name.endsWith(ext));
        if (!ok) throw { type: "format", message: `Unsupported file type: ${file.type || name}` };
        return true;
      }
      function handleFileSelect(file) { try { validateFile(file); currentFile = file; fileLabel.textContent = `Sélectionné : ${file.name}`; hideErrorMessage(); updateProcessButtonState(); } catch (e) { handleError(ERROR_TYPES.FILE, "File validation failed", e); currentFile = null; updateProcessButtonState(); } }

      function processAndSendAudio() {
        if (!currentFile || !socket || socket.readyState !== WebSocket.OPEN) { handleError(ERROR_TYPES.PROCESSING, "Cannot process audio: missing file or connection"); return; }
        processBtn.disabled = true; processBtn.textContent = "Traitement...";
        try {
          if (currentFile.type !== "audio/wav" && originalBuffer) {
            showProgress("Conversion de l'enregistrement en WAV...");
            audioBufferToWav(originalBuffer)
              .then((wavBlob) => { currentFile = new File([wavBlob], "recording.wav", { type: "audio/wav" }); sendFileToServer(); })
              .catch((e) => { handleError(ERROR_TYPES.AUDIO, "WAV conversion failed", e); resetUIafterProcessing(); });
          } else if (currentFile instanceof Blob && currentFile.size > 0) {
            sendFileToServer();
          } else if (currentFile instanceof File) {
            sendFileToServer();
          } else {
            handleError(ERROR_TYPES.PROCESSING, "Invalid audio file"); resetUIafterProcessing();
          }
        } catch (e) { handleError(ERROR_TYPES.PROCESSING, "Audio processing failed", e); resetUIafterProcessing(); }
      }
      function sendFileToServer() {
        showProgress("Lecture et envoi de l'audio au serveur...");
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const base64Audio = e.target.result.split(",")[1];
            if (!base64Audio) throw new Error("Failed to encode file to base64");
            const message = { action: "transcribe_audio", audio: base64Audio, metadata: { filename: currentFile.name || "recording.wav", size: currentFile.size, type: currentFile.type || "audio/wav" } };
            socket.send(JSON.stringify(message));
          } catch (err) { handleError(ERROR_TYPES.PROCESSING, "Failed to send audio data", err); resetUIafterProcessing(); }
        };
        reader.onerror = (err) => { handleError(ERROR_TYPES.FILE, "Failed to read audio file", err); resetUIafterProcessing(); };
        reader.readAsDataURL(currentFile);
      }
      function resetUIafterProcessing() { processBtn.disabled = false; processBtn.textContent = "Transcrire et Formater"; hideProgress(); updateProcessButtonState(); }

      // --- Wavesurfer ---
      function initializeWavesurfer() {
        try {
          wavesurfer = WaveSurfer.create({
            container: "#waveform",
            waveColor: "rgb(200, 200, 200)",
            progressColor: "rgb(100, 100, 200)",
            barWidth: 2,
            barGap: 1,
            barRadius: 2,
            cursorWidth: 2,
            cursorColor: "#4a9eff",
            height: 128,
            normalize: true,
            responsive: true,
            interact: true,
            backend: isSafari || isIOS ? "MediaElement" : "WebAudio",
          });

          wavesurfer.on("audioprocess", () => { if (!isDraggingProgress) updateProgressBar(wavesurfer.getCurrentTime(), wavesurfer.getDuration()); });
          wavesurfer.on("seek", () => { if (!isDraggingProgress) updateProgressBar(wavesurfer.getCurrentTime(), wavesurfer.getDuration()); });
          wavesurfer.on("play", () => { playBtn.textContent = "⏸️ Pause"; startProgressAnimation(); });
          wavesurfer.on("pause", () => { playBtn.textContent = "▶️ Play"; stopProgressAnimation(); });
          wavesurfer.on("finish", () => { playBtn.textContent = "▶️ Play"; stopProgressAnimation(); updateProgressBar(wavesurfer.getDuration(), wavesurfer.getDuration()); });
          wavesurfer.on("ready", () => {
            if (wavesurfer.backend && wavesurfer.backend.buffer) originalBuffer = wavesurfer.backend.buffer; else originalBuffer = null;
            updateRecorderUI(); updateProgressBar(0, wavesurfer.getDuration());
          });
          wavesurfer.on("error", (e) => handleError(ERROR_TYPES.AUDIO, "Waveform error", e));
        } catch (e) { handleError(ERROR_TYPES.AUDIO, "Failed to initialize waveform", e); }
      }

      function updateRecorderUI() {
        const hasRecording = wavesurfer && wavesurfer.getDuration() > 0;
        recordBtn.disabled = false;
        stopBtn.disabled = !isRecording && !isPaused;
        playBtn.disabled = isRecording || !hasRecording;
        rewindBtn.disabled = isRecording || !hasRecording;
        forwardBtn.disabled = isRecording || !hasRecording;
        deleteBtn.disabled = isRecording || !hasRecording;
        insertModeBtn.disabled = isRecording; overwriteModeBtn.disabled = isRecording;
        if (isRecording) { recordBtn.textContent = "⏸️"; recordBtn.classList.add("recording"); stopBtn.style.opacity = "1"; } else { recordBtn.textContent = "🎤"; recordBtn.classList.remove("recording"); stopBtn.style.opacity = stopBtn.disabled ? "0.5" : "1"; }
      }

      async function toggleRecording() {
        try { if (isRecording) { pauseRecording(); } else if (isPaused) { resumeRecording(); } else { await startRecording(); } updateRecorderUI(); } catch (e) { handleError(ERROR_TYPES.AUDIO, "Recording toggle failed", e); resetRecordingState(); }
      }
      function pauseRecording() { if (mediaRecorder && mediaRecorder.state === "recording") { mediaRecorder.pause(); isPaused = true; isRecording = false; stopRecordingTimer(); } }
      function resumeRecording() { if (mediaRecorder && mediaRecorder.state === "paused") { mediaRecorder.resume(); isPaused = false; isRecording = true; startRecordingTimer(); } }

      async function startRecording() {
        try {
          let audioConstraints = { echoCancellation: true, noiseSuppression: true, autoGainControl: true };
          if (isIOSSafari) audioConstraints = { echoCancellation: false, noiseSuppression: false, autoGainControl: false };
          else if (!isIOS) { audioConstraints.sampleRate = CONFIG.AUDIO_CONSTRAINTS.sampleRate; audioConstraints.channelCount = CONFIG.AUDIO_CONSTRAINTS.channels; }

          stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints }).catch(async () => await navigator.mediaDevices.getUserMedia({ audio: true }));

          const insertionTime = wavesurfer ? wavesurfer.getCurrentTime() : 0;
          let recordingStream = stream;
          if (originalBuffer && insertionTime > 0 && !isIOSSafari) {
            try { recordingStream = await prepareEditingStream(stream, insertionTime); } catch (e) { console.warn("Edit stream preparation failed; using direct stream", e); }
          }

          mediaRecorder = createMediaRecorder(recordingStream);
          audioChunks = [];
          mediaRecorder.start(250); // smaller chunks = more responsive
          isRecording = true; isPaused = false;
          recordStartMs = Date.now();
          startRecordingTimer();
          startSound.play().catch(() => {});
        } catch (e) {
          if (["NotAllowedError", "PermissionDeniedError"].includes(e.name)) handleError(ERROR_TYPES.PERMISSION, "Microphone access denied", e);
          else if (["NotFoundError", "DevicesNotFoundError"].includes(e.name)) handleError(ERROR_TYPES.AUDIO, "No microphone found", e);
          else if (["NotReadableError", "TrackStartError"].includes(e.name)) handleError(ERROR_TYPES.AUDIO, "Microphone is already in use", e);
          else handleError(ERROR_TYPES.AUDIO, "Failed to start recording", e);
          resetRecordingState();
        }
      }

      function startRecordingTimer() {
        stopRecordingTimer();
        recordElapsedTimer = setInterval(() => {
          const elapsed = (Date.now() - recordStartMs) / 1000;
          // During live recording, treat total = current (grows with time)
          updateProgressBar(elapsed, elapsed);
        }, 100);
      }
      function stopRecordingTimer() { if (recordElapsedTimer) { clearInterval(recordElapsedTimer); recordElapsedTimer = null; } }

      async function prepareEditingStream(micStream, insertionTime) {
        const AudioContextCls = window.AudioContext || window.webkitAudioContext;
        const audioContext = new AudioContextCls();
        const preSlice = sliceAudioBuffer(originalBuffer, 0, insertionTime);
        const sourceNode = audioContext.createBufferSource(); sourceNode.buffer = preSlice;
        const dest = audioContext.createMediaStreamDestination(); sourceNode.connect(dest); sourceNode.start();
        const micSource = audioContext.createMediaStreamSource(micStream); micSource.connect(dest);
        return dest.stream;
      }

      function createMediaRecorder(stream) {
        const mimeTypes = ["audio/webm;codecs=opus", "audio/webm", "audio/ogg;codecs=opus", "audio/mp4", "audio/mpeg"];
        let selected = ""; for (const t of mimeTypes) { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) { selected = t; break; } }
        const options = {}; if (selected) options.mimeType = selected; options.audioBitsPerSecond = isMobile ? 64000 : 128000;
        const rec = new MediaRecorder(stream, options);
        rec.ondataavailable = (e) => { if (e.data && e.data.size > 0) audioChunks.push(e.data); };
        rec.onstop = () => { processFinishedRecording(); };
        rec.onerror = (ev) => { handleError(ERROR_TYPES.AUDIO, "MediaRecorder error", ev.error); resetRecordingState(); };
        rec.onpause = () => {}; rec.onresume = () => {};
        return rec;
      }

      function stopRecording() {
        try {
          if (mediaRecorder && (mediaRecorder.state === "recording" || mediaRecorder.state === "paused")) {
            mediaRecorder.stop();
            if (stream) { stream.getTracks().forEach((t) => t.stop()); stream = null; }
            isRecording = false; isPaused = false; stopRecordingTimer();
            stopSound.play().catch(() => {});
          }
        } catch (e) { handleError(ERROR_TYPES.AUDIO, "Failed to stop recording", e); }
        finally { updateRecorderUI(); }
      }

      function resetRecordingState() { isRecording = false; isPaused = false; if (stream) { stream.getTracks().forEach((t) => t.stop()); stream = null; } mediaRecorder = null; stopRecordingTimer(); updateRecorderUI(); }

      async function processFinishedRecording() {
        try {
          if (audioChunks.length === 0) throw new Error("No audio data recorded");
          const recordedBlob = new Blob(audioChunks, { type: mediaRecorder?.mimeType || "audio/webm" });
          const AudioContextCls = window.AudioContext || window.webkitAudioContext;
          const ctx = new AudioContextCls();
          const arrayBuffer = await recordedBlob.arrayBuffer();
          const newRecordingBuffer = await ctx.decodeAudioData(arrayBuffer);
          const finalBuffer = await processAudioEditing(newRecordingBuffer);
          const wavBlob = await audioBufferToBlob(finalBuffer);
          if (wavesurfer) {
            const url = URL.createObjectURL(wavBlob);
            wavesurfer.load(url);
            wavesurfer.once("ready", () => URL.revokeObjectURL(url));
          }
          originalBuffer = finalBuffer;
          currentFile = new File([wavBlob], "recording.wav", { type: "audio/wav" });
        } catch (e) { handleError(ERROR_TYPES.AUDIO, "Failed to process recording", e); }
        finally { updateProcessButtonState(); resetRecordingState(); }
      }

      async function audioBufferToBlob(buffer) { try { const wavBlob = await audioBufferToWav(buffer); return wavBlob; } catch (e) { console.warn("WAV conversion failed, using WebM fallback:", e); const AudioContextCls = window.AudioContext || window.webkitAudioContext; const ctx = new AudioContextCls(); const dest = ctx.createMediaStreamDestination(); const src = ctx.createBufferSource(); src.buffer = buffer; src.connect(dest); const rec = new MediaRecorder(dest.stream); const chunks = []; return new Promise((resolve, reject) => { rec.ondataavailable = (ev) => chunks.push(ev.data); rec.onstop = () => resolve(new Blob(chunks, { type: "audio/webm" })); rec.onerror = reject; rec.start(); src.start(); src.onended = () => rec.stop(); }); } }

      async function processAudioEditing(newRecordingBuffer) {
        const insertionTime = wavesurfer ? wavesurfer.getCurrentTime() : 0;
        if (!originalBuffer || insertionTime === 0) return newRecordingBuffer;
        try {
          const preSlice = sliceAudioBuffer(originalBuffer, 0, insertionTime);
          if (editMode === "insert") {
            const postSlice = sliceAudioBuffer(originalBuffer, insertionTime, originalBuffer.duration);
            return concatAudioBuffers([preSlice, newRecordingBuffer, postSlice]);
          } else {
            const newEnd = insertionTime + newRecordingBuffer.duration;
            if (newEnd < originalBuffer.duration) { const postSlice = sliceAudioBuffer(originalBuffer, newEnd, originalBuffer.duration); return concatAudioBuffers([preSlice, newRecordingBuffer, postSlice]); }
            return concatAudioBuffers([preSlice, newRecordingBuffer]);
          }
        } catch (e) { console.warn("Audio editing failed, using new recording only:", e); return newRecordingBuffer; }
      }

      // --- Buffers ---
      function validateAudioBuffer(buffer) { if (!buffer || !buffer.sampleRate || !buffer.numberOfChannels || buffer.length === 0) throw new Error("Invalid audio buffer"); return true; }
      function sliceAudioBuffer(buffer, start, end) {
        validateAudioBuffer(buffer);
        if (start < 0) start = 0; if (end > buffer.duration) end = buffer.duration; if (start >= end) { const AudioContextCls = window.AudioContext || window.webkitAudioContext; const ctx = new AudioContextCls(); return ctx.createBuffer(buffer.numberOfChannels, 1, buffer.sampleRate); }
        const AudioContextCls = window.AudioContext || window.webkitAudioContext; const ctx = new AudioContextCls(); const rate = buffer.sampleRate; const s = Math.max(0, Math.round(rate * start)); const e = Math.min(buffer.length, Math.round(rate * end)); const frames = e - s; const out = ctx.createBuffer(buffer.numberOfChannels, frames, rate);
        for (let ch = 0; ch < buffer.numberOfChannels; ch++) { const data = buffer.getChannelData(ch); out.copyToChannel(data.slice(s, e), ch); }
        return out;
      }
      function concatAudioBuffers(buffers) {
        if (!buffers || buffers.length === 0) throw new Error("No buffers to concatenate");
        buffers.forEach((b, i) => validateAudioBuffer(b));
        const first = buffers[0];
        const AudioContextCls = window.AudioContext || window.webkitAudioContext; const ctx = new AudioContextCls();
        const rate = first.sampleRate; const chans = first.numberOfChannels; const total = buffers.reduce((a, b) => a + b.length, 0);
        const out = ctx.createBuffer(chans, total, rate);
        let offset = 0; for (const b of buffers) { for (let ch = 0; ch < Math.min(chans, b.numberOfChannels); ch++) { out.getChannelData(ch).set(b.getChannelData(ch), offset); } offset += b.length; }
        return out;
      }
      function updateTimeline(current, total) { timeline.textContent = `${formatTime(current)} / ${formatTime(total)}`; }
      function formatTime(time) { if (!time || isNaN(time)) time = 0; const m = Math.floor(time / 60); const s = Math.floor(time % 60); const d = Math.floor((time % 1) * 10); return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}.${d}`; }

      // --- WAV conversion (16-bit PCM, 8 kHz mono) ---
      async function audioBufferToWav(buffer) {
        validateAudioBuffer(buffer);
        const targetSampleRate = CONFIG.AUDIO_CONSTRAINTS.sampleRate;
        const targetChannels = CONFIG.AUDIO_CONSTRAINTS.channels;
        let processed = buffer;
        if (buffer.sampleRate !== targetSampleRate || buffer.numberOfChannels !== targetChannels) processed = await resampleAudioBuffer(buffer, targetSampleRate, targetChannels);
        const pcm = processed.getChannelData(0);
        const dataView = encodePCMToInt16(pcm);
        const wavView = createWavFile(dataView, targetSampleRate, targetChannels);
        return new Blob([wavView], { type: "audio/wav" });
      }
      async function resampleAudioBuffer(buffer, targetRate, targetChannels) {
        const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;
        const offline = new OfflineCtx(targetChannels, Math.ceil(buffer.duration * targetRate), targetRate);
        const src = offline.createBufferSource(); src.buffer = buffer; src.connect(offline.destination); src.start();
        return await offline.startRendering();
      }
      function encodePCMToInt16(samples) {
        const buf = new ArrayBuffer(samples.length * 2); const view = new DataView(buf);
        for (let i = 0; i < samples.length; i++) { let s = Math.max(-1, Math.min(1, samples[i])); const v = s < 0 ? s * 0x8000 : s * 0x7fff; view.setInt16(i * 2, Math.round(v), true); }
        return view;
      }
      function createWavFile(dataView, sampleRate, numChannels) {
        const dataLen = dataView.byteLength; const buffer = new ArrayBuffer(44 + dataLen); const view = new DataView(buffer);
        writeString(view, 0, "RIFF"); view.setUint32(4, 36 + dataLen, true); writeString(view, 8, "WAVE");
        writeString(view, 12, "fmt "); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2 * numChannels, true); view.setUint16(32, numChannels * 2, true); view.setUint16(34, 16, true);
        writeString(view, 36, "data"); view.setUint32(40, dataLen, true);
        new Uint8Array(buffer, 44).set(new Uint8Array(dataView.buffer));
        return view;
      }
      function writeString(view, offset, str) { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); }

      // --- Listeners ---
      function setupEventListeners() { setupTabListeners(); setupUploadListeners(); setupRecorderListeners(); setupActionListeners(); setupKeyboardShortcuts(); }
      function setupTabListeners() {
        document.querySelectorAll(".tab-button").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            const tabId = btn.dataset.tab;
            document.querySelectorAll(".tab-button").forEach((b) => b.classList.remove("active"));
            document.querySelectorAll(".tab-pane").forEach((p) => p.classList.remove("active"));
            btn.classList.add("active");
            document.getElementById(tabId).classList.add("active");
            clickSound.play().catch(() => {});
          });
        });
      }
      function setupUploadListeners() {
        ["dragenter", "dragover", "dragleave", "drop"].forEach((ev) => { dropzone.addEventListener(ev, preventDefaults, false); document.body.addEventListener(ev, preventDefaults, false); });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
        ["dragenter", "dragover"].forEach((ev) => dropzone.addEventListener(ev, () => dropzone.classList.add("dragover"), false));
        ["dragleave", "drop"].forEach((ev) => dropzone.addEventListener(ev, () => dropzone.classList.remove("dragover"), false));
        dropzone.addEventListener("drop", (e) => { const dt = e.dataTransfer; if (dt.files && dt.files.length > 0) handleFileSelect(dt.files[0]); }, false);
        browseBtn.addEventListener("click", (e) => { e.preventDefault(); fileInput.click(); });
        fileInput.addEventListener("change", (e) => { if (e.target.files.length > 0) handleFileSelect(e.target.files[0]); });
      }
      function setupRecorderListeners() {
        recordBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); toggleRecording(); clickSound.play().catch(() => {}); });
        stopBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!stopBtn.disabled) stopRecording(); });
        playBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!playBtn.disabled && wavesurfer) { try { wavesurfer.playPause(); clickSound.play().catch(() => {}); } catch (err) { handleError(ERROR_TYPES.AUDIO, "Playback failed", err); } } });
        rewindBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!rewindBtn.disabled && wavesurfer) { try { const t = Math.max(0, wavesurfer.getCurrentTime() - 3); wavesurfer.seekTo(t / wavesurfer.getDuration()); updateProgressBar(t, wavesurfer.getDuration()); clickSound.play().catch(() => {}); } catch (err) {} } });
        forwardBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!forwardBtn.disabled && wavesurfer) { try { const d = wavesurfer.getDuration(); const t = Math.min(d, wavesurfer.getCurrentTime() + 3); wavesurfer.seekTo(t / d); updateProgressBar(t, d); clickSound.play().catch(() => {}); } catch (err) {} } });
        deleteBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!deleteBtn.disabled) deleteRecording(); });
        insertModeBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!insertModeBtn.disabled) setEditMode("insert"); });
        overwriteModeBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); if (!overwriteModeBtn.disabled) setEditMode("overwrite"); });
        [recordBtn, stopBtn, playBtn, rewindBtn, forwardBtn, deleteBtn, insertModeBtn, overwriteModeBtn].forEach((btn) => { btn.addEventListener("touchstart", (e) => { e.preventDefault(); btn.click(); }, { passive: false }); });
      }
      function deleteRecording() {
        if (confirm("Êtes-vous sûr de vouloir effacer l'enregistrement?")) {
          try { if (wavesurfer && wavesurfer.isPlaying()) wavesurfer.stop(); if (wavesurfer) wavesurfer.empty(); originalBuffer = null; currentFile = null; audioChunks = []; updateProgressBar(0, 0); updateTimeline(0, 0); updateRecorderUI(); updateProcessButtonState(); showNotification("Enregistrement effacé"); } catch (e) { handleError(ERROR_TYPES.AUDIO, "Failed to delete recording", e); }
        }
      }
      function setEditMode(mode) { if (mode === editMode) return; editMode = mode; insertModeBtn.classList.toggle("active", mode === "insert"); overwriteModeBtn.classList.toggle("active", mode === "overwrite"); showNotification(mode === "insert" ? "Mode: Insérer" : "Mode: Écraser"); clickSound.play().catch(() => {}); }

      function setupActionListeners() {
        processBtn.addEventListener("click", (e) => { e.preventDefault(); processAndSendAudio(); });
        newSessionBtn.addEventListener("click", (e) => { e.preventDefault(); resetToStart(); });
        copyBtn.addEventListener("click", (e) => { e.preventDefault(); copyFormattedText(); });
        saveBtn.addEventListener("click", (e) => { e.preventDefault(); saveTextToFile(); });
      }
      function setupKeyboardShortcuts() {
        document.addEventListener("keydown", (e) => {
          if (["INPUT", "TEXTAREA"].includes(e.target.tagName)) return;
          if (e.code === "Space" && wavesurfer && wavesurfer.getDuration() > 0 && !isRecording) { e.preventDefault(); wavesurfer.playPause(); }
          if (e.code === "KeyR" && !e.metaKey && !e.ctrlKey) { e.preventDefault(); toggleRecording(); }
          if (e.code === "KeyS" && !e.metaKey && !e.ctrlKey) { e.preventDefault(); stopRecording(); }
          if (e.code === "ArrowLeft" && wavesurfer && !isRecording) { e.preventDefault(); rewindBtn.click(); }
          if (e.code === "ArrowRight" && wavesurfer && !isRecording) { e.preventDefault(); forwardBtn.click(); }
        });
      }

      // --- Text formatting & output ---
      function formatTextAsHtml(text) {
        if (!text) return "";
        try {
          const lines = text.split("\n");
          const formatted = lines.map((line) => {
            let s = line.trim();
            const bold = "font-weight:bold;";
            s = s.replace(/\*\*(.*?)\*\*/g, `<span style="${bold}">$1</span>`);
            if (!s.includes(bold) && s.length > 0 && s === s.toUpperCase()) s = `<span style="${bold}">${s}</span>`;
            return s;
          });
          return formatted.join("<br>");
        } catch (e) { return text; }
      }
      function copyFormattedText() {
        try {
          const html = resultText.innerHTML;
          const wordHtml = html.replace(/<br\s*\/?>(?=.)/gi, "</p><p>");
          const styled = `\n<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head><meta charset="utf-8"><style>p{margin:0;font-family:Arial,sans-serif;font-size:11pt;line-height:1.5}span[style*='font-weight:bold']{font-weight:bold!important}</style></head><body><p>${wordHtml}</p></body></html>`;
          const plain = resultText.innerText;
          if (navigator.clipboard && navigator.clipboard.write && !isIOS) {
            const htmlBlob = new Blob([styled], { type: "text/html" });
            const textBlob = new Blob([plain], { type: "text/plain" });
            const item = new ClipboardItem({ "text/html": htmlBlob, "text/plain": textBlob });
            navigator.clipboard.write([item]).then(() => showNotification("Rapport copié avec formatage !")).catch(() => fallbackCopy(plain));
          } else fallbackCopy(plain);
        } catch (e) { handleError(ERROR_TYPES.PROCESSING, "Copy failed", e); }
      }
      function fallbackCopy(text) {
        try {
          const ta = document.createElement("textarea");
          ta.value = text; ta.style.position = "fixed"; ta.style.opacity = "0"; ta.style.left = "-9999px"; document.body.appendChild(ta);
          ta.select(); ta.setSelectionRange(0, text.length);
          const ok = document.execCommand("copy"); document.body.removeChild(ta);
          if (ok) showNotification("Rapport copié !"); else if (navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(text).then(() => showNotification("Rapport copié !")).catch(() => showNotification("Échec de la copie", "error")); else showNotification("Échec de la copie", "error");
        } catch (e) { showNotification("Échec de la copie", "error"); }
      }
      function showNotification(message, type = "success") {
        const n = document.createElement("div");
        n.textContent = message;
        n.style.cssText = `position:fixed;top:20px;right:20px;padding:12px 20px;background-color:${type === "success" ? "var(--success-color)" : "var(--error-color)"};color:white;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,0.3);z-index:1000;animation:slideIn .3s ease-out;`;
        const style = document.createElement("style"); style.textContent = `@keyframes slideIn{from{transform:translateX(100%);opacity:0}to{transform:translateX(0);opacity:1}}`; document.head.appendChild(style);
        document.body.appendChild(n);
        setTimeout(() => { n.style.animation = "slideIn .3s ease-out reverse"; setTimeout(() => { document.body.removeChild(n); document.head.removeChild(style); }, 300); }, 3000);
      }
      function saveTextToFile() {
        try {
          const text = resultText.innerText; if (!text) { showNotification("Aucun texte à sauvegarder", "error"); return; }
          const ts = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -5);
          const filename = `rapport_medivox_${ts}.txt`;
          const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
          if (window.navigator && window.navigator.msSaveOrOpenBlob) window.navigator.msSaveOrOpenBlob(blob, filename);
          else { const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = filename; a.style.display = "none"; document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(a.href); }, 100); }
          showNotification("Fichier sauvegardé !");
        } catch (e) { handleError(ERROR_TYPES.PROCESSING, "File save failed", e); }
      }

      document.addEventListener("visibilitychange", () => { if (document.hidden) stopProgressAnimation(); else if (wavesurfer && wavesurfer.isPlaying()) startProgressAnimation(); });
      window.addEventListener("beforeunload", () => { if (socket) socket.close(); if (stream) stream.getTracks().forEach((t) => t.stop()); if (wavesurfer) wavesurfer.destroy(); stopProgressAnimation(); stopRecordingTimer(); });
    });
  </script>
</body>
</html>
