<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Medivox</title>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --container-bg: #2d2d2d;
            --text-color: #ffffff;
            --primary-color: #4a9eff;
            --secondary-color: #252525;
            --tertiary-color: #353535;
            --success-color: #4CAF50;
            --error-color: #ff4444;
            --warning-color: #ffa500;
            --disabled-color: #666666;
            --font-family: 'Arial', sans-serif;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .main-container {
            width: 100%;
            max-width: 900px;
            background-color: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
        }
        h1 {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
        }
        .status-bar {
            background-color: var(--secondary-color);
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            text-align: right;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #connectionStatus {
            font-weight: bold;
            color: var(--error-color);
        }
        #connectionStatus::before {
            content: '‚óè';
            margin-right: 8px;
        }
        .error-message {
            background-color: rgba(255, 68, 68, 0.1);
            border: 1px solid var(--error-color);
            color: var(--error-color);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
        }

        /* --- Tabs --- */
        .tabs {
            display: flex;
            margin-bottom: -2px; /* Overlap border */
            z-index: 1;
            position: relative;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: var(--secondary-color);
            border: 2px solid var(--tertiary-color);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            margin-right: 5px;
            color: #ccc;
        }
        .tab-button.active {
            background-color: var(--container-bg);
            border-color: var(--tertiary-color);
            color: var(--primary-color);
            font-weight: bold;
        }
        .tab-content {
            background-color: var(--container-bg);
            padding: 40px 20px;
            text-align: center;
            border-radius: 8px;
            border-top-left-radius: 0;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--tertiary-color);
            margin-bottom: 20px;
        }
        #upload-tab-content {
            border-top-left-radius: 0;
        }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }


        /* --- Upload Section --- */
        #dropzone {
            width: 100%;
            transition: border-color 0.3s;
            padding: 0;
            border: 2px dashed var(--tertiary-color);
            border-radius: 8px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }
        #dropzone.dragover {
            border-color: var(--primary-color);
            background-color: var(--secondary-color);
        }
        #dropzone-icon { font-size: 48px; }
        #dropzone-text { font-size: 16px; color: #ccc; margin: 10px 0; }
        #browseBtn {
             background-color: var(--primary-color);
             color: white;
             padding: 10px 20px;
             font-size: 14px;
             border: none;
             border-radius: 4px;
             cursor: pointer;
        }
        #fileLabel {
             margin-top: 15px;
             font-style: italic;
             color: var(--primary-color);
        }

        /* --- Recorder Section --- */
        #recorder-tab-content {
             gap: 15px;
        }
        #waveform {
             width: 100%;
             height: 128px;
        }
        #controls-timeline, #main-controls, #edit-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            width: 100%;
        }
        #main-controls button, #edit-controls button {
            padding: 10px 15px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            font-size: 16px;
            background: var(--tertiary-color);
            color: white;
            min-width: 50px;
        }
        #main-controls #recordBtn {
            background-color: var(--error-color);
            width: 60px;
            height: 60px;
            font-size: 24px;
        }
        #main-controls #recordBtn.recording {
            background-color: #ff8c00; /* Orange for pause */
        }
         #main-controls #stopBtn {
            background-color: var(--secondary-color);
             width: 60px;
             height: 60px;
             font-size: 24px;
        }
        #timeline {
            font-family: 'Courier New', Courier, monospace;
            font-size: 18px;
            color: var(--primary-color);
        }
        .edit-mode-toggle {
            display: flex;
            background-color: var(--secondary-color);
            border-radius: 20px;
            padding: 4px;
        }
        .edit-mode-toggle button {
            background: transparent;
            border: none;
            padding: 6px 15px;
            border-radius: 16px;
            color: #ccc;
            cursor: pointer;
        }
        .edit-mode-toggle button.active {
            background-color: var(--primary-color);
            color: white;
        }


        /* --- Common/Result Section --- */
        .actions-bar, .result-header, .result-actions {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .actions-bar {
            background-color: var(--bg-color);
            justify-content: flex-start;
        }
        label { margin-right: 10px; }
        select {
            background-color: var(--tertiary-color);
            color: var(--text-color);
            border: 1px solid var(--tertiary-color);
            padding: 8px 10px;
            border-radius: 4px;
            font-size: 14px;
        }
        #processBtn {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #processBtn:disabled {
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }
        #progressLabel {
            margin-left: 20px;
            font-size: 14px;
            color: var(--primary-color);
            display: none;
        }
        .result-section { display: none; }
        .result-header { justify-content: space-between; }
        .result-header h2 {
            font-size: 18px;
            font-weight: bold;
            color: var(--success-color);
            margin: 0;
        }
        #newSessionBtn, #copyBtn, #saveBtn {
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s;
            color: white;
            padding: 8px 15px;
        }
        #newSessionBtn { background-color: var(--container-bg); }
        #resultText {
            width: 100%;
            max-height: 70vh;
            overflow-y: auto;
            background-color: var(--container-bg);
            color: var(--text-color);
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            padding: 15px;
            box-sizing: border-box;
            text-align: left;
            font-family: Arial, sans-serif;
            font-size: 11pt;
            line-height: 1.5;
        }
        #resultText span[style*="font-weight:bold"] { font-weight: bold !important; }
        .result-actions { justify-content: center; gap: 20px; margin-bottom: 0; }
        #copyBtn { background-color: var(--success-color); }
        #saveBtn { background-color: #2196F3; }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>Medivox HDL</h1>
        <div class="status-bar">
            <div class="error-message" id="errorMessage"></div>
            <div id="connectionStatus">D√©connect√©</div>
        </div>

        <div id="processing-container">
            <div class="tabs">
                <button class="tab-button active" data-tab="upload-tab">T√©l√©verser un fichier</button>
                <button class="tab-button" data-tab="recorder-tab">Enregistrer un Audio</button>
            </div>

            <div id="upload-tab" class="tab-pane active">
                <div class="tab-content">
                    <div id="dropzone">
                        <div id="dropzone-icon">üìÅ</div>
                        <div id="dropzone-text">Glissez-d√©posez votre fichier audio ici, ou cliquez sur Parcourir</div>
                        <input type="file" id="fileInput" accept="audio/*" hidden>
                        <button id="browseBtn">Parcourir</button>
                        <div id="fileLabel"></div>
                    </div>
                </div>
            </div>

            <div id="recorder-tab" class="tab-pane">
                <div class="tab-content">
                    <div id="waveform"></div>
                    <div id="controls-timeline">
                        <span id="timeline">00:00.0 / 00:00.0</span>
                    </div>
                    <div id="edit-controls">
                         <button id="playBtn">‚ñ∂Ô∏è Play</button>
                         <button id="rewindBtn">‚è™ 3s</button>
                         <button id="forwardBtn">3s ‚è©</button>
                         <div class="edit-mode-toggle">
                            <button id="insertModeBtn" class="active" title="Insert new audio at cursor position">Ins√©rer</button>
                            <button id="overwriteModeBtn" title="Record over existing audio from cursor position">√âcraser</button>
                         </div>
                    </div>
                     <div id="main-controls">
                         <button id="recordBtn" title="Record/Pause">üé§</button>
                         <button id="stopBtn" title="Stop Recording">‚èπÔ∏è</button>
                     </div>
                </div>
            </div>
            
            <div class="actions-bar">
                <div>
                    <label for="templateSelect">Mod√®le :</label>
                    <select id="templateSelect">
                        <option value="Standard">Standard</option>
                    </select>
                </div>
                <button id="processBtn" disabled>Transcrire et Formater</button>
                <div id="progressLabel"></div>
            </div>
        </div>

        <div id="resultSection" class="result-section">
            <div class="result-header">
                <h2>‚úÖ Rapport Pr√™t</h2>
                <button id="newSessionBtn">Nouvelle Session</button>
            </div>
            <div id="resultText"></div>
            <div class="result-actions">
                <button id="copyBtn">Copier le Rapport</button>
                <button id="saveBtn">Enregistrer dans un Fichier</button>
            </div>
        </div>
    </div>
    
    <audio id="click-sound" src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA" preload="auto"></audio>
    <audio id="start-sound" src="data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAACA" preload="auto"></audio>
    <audio id="stop-sound" src="data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAAE" preload="auto"></audio>

   <script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Constants & Configuration ---
    const CONFIG = {
        SERVER_ADDRESS: 'my-radiology-server.medivox.ca',
        RECONNECT_DELAY: 5000,
        MAX_RECONNECT_ATTEMPTS: 5,
        AUDIO_CONSTRAINTS: {
            sampleRate: 8000,
            channels: 1,
            bitDepth: 16
        },
        SUPPORTED_AUDIO_TYPES: ['audio/wav', 'audio/mp3', 'audio/m4a', 'audio/ogg', 'audio/webm'],
        MAX_FILE_SIZE: 50 * 1024 * 1024 // 50MB
    };

    // --- Error Types ---
    const ERROR_TYPES = {
        CONNECTION: 'connection',
        AUDIO: 'audio',
        FILE: 'file',
        PROCESSING: 'processing',
        PERMISSION: 'permission'
    };

    // --- Global State ---
    let socket = null;
    let currentFile = null;
    let transcribedText = "";
    let reconnectAttempts = 0;
    
    // --- UI Elements ---
    const connectionStatus = document.getElementById('connectionStatus');
    const errorMessage = document.getElementById('errorMessage');
    const processBtn = document.getElementById('processBtn');
    const progressLabel = document.getElementById('progressLabel');
    const processingContainer = document.getElementById('processing-container');
    const resultSection = document.getElementById('resultSection');
    const resultText = document.getElementById('resultText');
    const newSessionBtn = document.getElementById('newSessionBtn');
    const copyBtn = document.getElementById('copyBtn');
    const saveBtn = document.getElementById('saveBtn');

    // --- Upload Elements ---
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const browseBtn = document.getElementById('browseBtn');
    const fileLabel = document.getElementById('fileLabel');

    // --- Recorder Elements ---
    const recordBtn = document.getElementById('recordBtn');
    const stopBtn = document.getElementById('stopBtn');
    const playBtn = document.getElementById('playBtn');
    const rewindBtn = document.getElementById('rewindBtn');
    const forwardBtn = document.getElementById('forwardBtn');
    const insertModeBtn = document.getElementById('insertModeBtn');
    const overwriteModeBtn = document.getElementById('overwriteModeBtn');
    const timeline = document.getElementById('timeline');

    // --- Sound Elements ---
    const clickSound = document.getElementById('click-sound');
    const startSound = document.getElementById('start-sound');
    const stopSound = document.getElementById('stop-sound');
    
    // --- Recorder State ---
    let wavesurfer, mediaRecorder, stream;
    let audioChunks = [];
    let isRecording = false;
    let isPaused = false;
    let editMode = 'insert';
    let originalBuffer = null;
    
    // --- iOS Detection and Compatibility ---
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    const isIOSSafari = isIOS && /Safari/.test(navigator.userAgent) && !/CriOS|FxiOS/.test(navigator.userAgent);
    
    // --- Initialize Application ---
    initializeApplication();

    function initializeApplication() {
        try {
            if (isIOS) {
                initializeIOSCompatibility();
            }
            initializeWavesurfer();
            connectWebSocket();
            setupEventListeners();
            updateRecorderUI();
        } catch (error) {
            handleError(ERROR_TYPES.PROCESSING, 'Failed to initialize application', error);
        }
    }

    function initializeIOSCompatibility() {
        // iOS-specific audio context initialization
        if (isIOS && window.AudioContext) {
            // Create a dummy audio context to enable Web Audio API on iOS
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Add click handler to enable audio context on first user interaction
            const enableAudioContext = () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('iOS Audio context enabled');
                    }).catch(err => {
                        console.warn('Failed to enable iOS audio context:', err);
                    });
                }
                // Remove listener after first activation
                document.removeEventListener('touchstart', enableAudioContext);
                document.removeEventListener('click', enableAudioContext);
            };
            
            document.addEventListener('touchstart', enableAudioContext, { once: true });
            document.addEventListener('click', enableAudioContext, { once: true });
        }
        
        // Show iOS-specific warnings if needed
        if (isIOS && window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
            showErrorMessage("HTTPS requis pour l'enregistrement audio sur iPhone/iPad", 'error');
        }
    }

    // --- Enhanced Error Handling System ---
    function handleError(type, message, error = null) {
        console.error(`[${type.toUpperCase()}] ${message}:`, error);
        
        let userMessage = message;
        let severity = 'error';
        
        switch (type) {
            case ERROR_TYPES.CONNECTION:
                userMessage = getConnectionErrorMessage(error);
                severity = reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS ? 'warning' : 'error';
                break;
                
            case ERROR_TYPES.AUDIO:
                userMessage = getAudioErrorMessage(error);
                break;
                
            case ERROR_TYPES.FILE:
                userMessage = getFileErrorMessage(error);
                break;
                
            case ERROR_TYPES.PERMISSION:
                userMessage = "Permissions requises non accord√©es. Veuillez autoriser l'acc√®s au microphone.";
                break;
                
            case ERROR_TYPES.PROCESSING:
                userMessage = "Erreur de traitement. Veuillez r√©essayer.";
                break;
        }
        
        showErrorMessage(userMessage, severity);
        
        // Auto-recovery for certain error types
        if (type === ERROR_TYPES.CONNECTION && reconnectAttempts < CONFIG.MAX_RECONNECT_ATTEMPTS) {
            setTimeout(() => connectWebSocket(), CONFIG.RECONNECT_DELAY);
        }
    }

    function getConnectionErrorMessage(error) {
        if (!error) return "Erreur de connexion inconnue";
        
        const errorMessages = {
            1006: "Connexion ferm√©e de mani√®re inattendue",
            1011: "Erreur serveur interne",
            1012: "Service en cours de red√©marrage"
        };
        
        return errorMessages[error.code] || `Erreur de connexion: ${error.message || 'Code ' + error.code}`;
    }

    function getAudioErrorMessage(error) {
        if (!error) return "Erreur audio inconnue";
        
        const audioErrorMessages = {
            'NotAllowedError': "Permission d'acc√®s au microphone refus√©e",
            'NotFoundError': "Aucun microphone d√©tect√©",
            'NotReadableError': "Microphone en cours d'utilisation par une autre application",
            'OverconstrainedError': "Param√®tres audio non support√©s",
            'SecurityError': "Acc√®s microphone bloqu√© (HTTPS requis)"
        };
        
        return audioErrorMessages[error.name] || `Erreur audio: ${error.message}`;
    }

    function getFileErrorMessage(error) {
        if (!error) return "Erreur de fichier inconnue";
        
        if (error.type === 'size') return `Fichier trop volumineux (max ${CONFIG.MAX_FILE_SIZE / (1024*1024)}MB)`;
        if (error.type === 'format') return "Format de fichier non support√©";
        
        return `Erreur de fichier: ${error.message}`;
    }

    function showErrorMessage(message, severity = 'error') {
        errorMessage.textContent = message;
        errorMessage.className = `error-message ${severity}`;
        errorMessage.style.display = 'block';
        
        // Auto-hide non-critical errors after 10 seconds
        if (severity === 'warning') {
            setTimeout(hideErrorMessage, 10000);
        }
    }

    function hideErrorMessage() {
        errorMessage.style.display = 'none';
    }

    // --- Enhanced WebSocket Logic ---
    function connectWebSocket() {
        if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
            return;
        }

        const url = `wss://${CONFIG.SERVER_ADDRESS}`;
        connectionStatus.textContent = 'Connexion...';
        connectionStatus.style.color = 'var(--warning-color)';
        
        try {
            socket = new WebSocket(url);
            setupWebSocketHandlers();
        } catch (error) {
            handleError(ERROR_TYPES.CONNECTION, 'Failed to create WebSocket connection', error);
            reconnectAttempts++;
        }
    }

    function setupWebSocketHandlers() {
        socket.onopen = () => {
            console.log('Connected to server');
            reconnectAttempts = 0;
            updateUIForConnection(true);
            hideErrorMessage();
            showProgress("Connect√© au serveur de transcription.");
            setTimeout(hideProgress, 3000);
        };

        socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleServerMessage(data);
            } catch (error) {
                handleError(ERROR_TYPES.PROCESSING, 'Invalid server response', error);
            }
        };

        socket.onerror = (error) => {
            handleError(ERROR_TYPES.CONNECTION, 'WebSocket error occurred', error);
            updateUIForConnection(false);
        };

        socket.onclose = (event) => {
            console.log('Disconnected from server');
            socket = null;
            updateUIForConnection(false);
            
            if (!event.wasClean) {
                reconnectAttempts++;
                handleError(ERROR_TYPES.CONNECTION, 'Connection lost', { code: event.code, message: event.reason });
            }
        };
    }
    
    function handleServerMessage(data) {
        const { action, message, text, performance, error: serverError } = data;
        
        try {
            switch (action) {
                case 'progress':
                    showProgress(message);
                    break;
                    
                case 'transcription_complete':
                    if (!text) {
                        throw new Error('No transcription text received');
                    }
                    transcribedText = text;
                    const speed = performance ? `(${performance.speed || 'N/A'})` : '';
                    showProgress(`Transcription termin√©e ${speed}. Mise en forme en cours...`);
                    requestFormatting();
                    break;
                    
                case 'formatting_complete':
                    if (!text) {
                        throw new Error('No formatted text received');
                    }
                    hideProgress();
                    resultText.innerHTML = formatTextAsHtml(text);
                    processBtn.disabled = false;
                    processBtn.textContent = "Transcrire et Formater";
                    toggleSections(true);
                    break;
                    
                case 'error':
                    throw new Error(message || serverError || 'Unknown server error');
                    
                default:
                    console.warn('Unknown server action:', action);
            }
        } catch (error) {
            handleError(ERROR_TYPES.PROCESSING, 'Server message processing failed', error);
            resetUIafterProcessing();
        }
    }
    
    function requestFormatting() {
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            throw new Error('WebSocket not connected');
        }
        
        if (!transcribedText) {
            throw new Error('No transcribed text to format');
        }
        
        const message = {
            action: "format_text",
            text: transcribedText
        };
        
        try {
            socket.send(JSON.stringify(message));
        } catch (error) {
            handleError(ERROR_TYPES.CONNECTION, 'Failed to send formatting request', error);
        }
    }
    
    // --- UI State Management ---
    function updateUIForConnection(isConnected) {
        if (isConnected) {
            connectionStatus.textContent = 'Connect√©';
            connectionStatus.style.color = 'var(--success-color)';
        } else {
            connectionStatus.textContent = 'D√©connect√©';
            connectionStatus.style.color = 'var(--error-color)';
        }
        updateProcessButtonState();
    }
    
    function updateProcessButtonState() {
        const isConnected = socket && socket.readyState === WebSocket.OPEN;
        processBtn.disabled = !isConnected || !currentFile;
    }

    function showProgress(message) {
        progressLabel.textContent = message;
        progressLabel.style.display = 'block';
    }

    function hideProgress() {
        progressLabel.style.display = 'none';
    }

    function toggleSections(showResult) {
        resultSection.style.display = showResult ? 'block' : 'none';
        processingContainer.style.display = showResult ? 'none' : 'block';
    }

    function resetToStart() {
        toggleSections(false);
        currentFile = null;
        transcribedText = "";
        fileLabel.textContent = "";
        resultText.innerHTML = "";
        fileInput.value = '';
        
        // Reset recorder state
        resetRecorderState();
        updateProcessButtonState();
    }

    function resetRecorderState() {
        if (wavesurfer) {
            wavesurfer.empty();
        }
        originalBuffer = null;
        updateTimeline(0, 0);
        updateRecorderUI();
    }
    
    // --- Enhanced File Handling ---
    function validateFile(file) {
        if (!file) {
            throw { type: 'format', message: 'No file provided' };
        }
        
        if (file.size > CONFIG.MAX_FILE_SIZE) {
            throw { type: 'size', message: `File size (${Math.round(file.size/(1024*1024))}MB) exceeds limit` };
        }
        
        const isValidType = CONFIG.SUPPORTED_AUDIO_TYPES.some(type => 
            file.type === type || file.name.toLowerCase().endsWith(type.split('/')[1])
        );
        
        if (!isValidType) {
            throw { type: 'format', message: `Unsupported file type: ${file.type}` };
        }
        
        return true;
    }

    function handleFileSelect(file) {
        try {
            validateFile(file);
            currentFile = file;
            fileLabel.textContent = `S√©lectionn√© : ${file.name}`;
            hideErrorMessage();
            updateProcessButtonState();
        } catch (error) {
            handleError(ERROR_TYPES.FILE, 'File validation failed', error);
            currentFile = null;
            updateProcessButtonState();
        }
    }

    function processAndSendAudio() {
        if (!currentFile || !socket || socket.readyState !== WebSocket.OPEN) {
            handleError(ERROR_TYPES.PROCESSING, 'Cannot process audio: missing file or connection');
            return;
        }

        processBtn.disabled = true;
        processBtn.textContent = 'Traitement...';

        try {
            // If currentFile is a recorded blob, convert it to WAV first
            if (currentFile.type !== 'audio/wav' && originalBuffer) {
                showProgress("Conversion de l'enregistrement en WAV...");
                audioBufferToWav(originalBuffer)
                    .then(wavBlob => {
                        currentFile = new File([wavBlob], "recording.wav", {type: "audio/wav"});
                        sendFileToServer();
                    })
                    .catch(error => {
                        handleError(ERROR_TYPES.AUDIO, "WAV conversion failed", error);
                        resetUIafterProcessing();
                    });
            } else {
                sendFileToServer();
            }
        } catch (error) {
            handleError(ERROR_TYPES.PROCESSING, 'Audio processing failed', error);
            resetUIafterProcessing();
        }
    }

    function sendFileToServer() {
        showProgress("Lecture et envoi de l'audio au serveur...");
        
        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const base64Audio = e.target.result.split(',')[1];
                if (!base64Audio) {
                    throw new Error('Failed to encode file to base64');
                }
                
                const message = {
                    action: "transcribe_audio",
                    audio: base64Audio,
                    metadata: {
                        filename: currentFile.name,
                        size: currentFile.size,
                        type: currentFile.type
                    }
                };
                
                socket.send(JSON.stringify(message));
            } catch (error) {
                handleError(ERROR_TYPES.PROCESSING, 'Failed to send audio data', error);
                resetUIafterProcessing();
            }
        };
        
        reader.onerror = (error) => {
            handleError(ERROR_TYPES.FILE, 'Failed to read audio file', error);
            resetUIafterProcessing();
        };
        
        reader.readAsDataURL(currentFile);
    }
    
    function resetUIafterProcessing() {
        processBtn.disabled = false;
        processBtn.textContent = 'Transcrire et Formater';
        hideProgress();
        updateProcessButtonState();
    }
    
    // --- Enhanced Recorder Logic ---
    function initializeWavesurfer() {
        try {
            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: 'rgb(200, 200, 200)',
                progressColor: 'rgb(100, 100, 200)',
                barWidth: 2,
                barGap: 1,
                barRadius: 2,
                cursorWidth: 2,
                cursorColor: '#4a9eff',
                height: 128,
            });

            wavesurfer.on('audioprocess', () => updateTimeline(wavesurfer.getCurrentTime(), wavesurfer.getDuration()));
            wavesurfer.on('seek', () => updateTimeline(wavesurfer.getCurrentTime(), wavesurfer.getDuration()));
            wavesurfer.on('finish', () => playBtn.textContent = '‚ñ∂Ô∏è Play');
            wavesurfer.on('ready', () => {
                originalBuffer = wavesurfer.getDecodedData();
                updateRecorderUI();
                updateTimeline(0, wavesurfer.getDuration());
            });
            wavesurfer.on('error', (error) => {
                handleError(ERROR_TYPES.AUDIO, 'Waveform error', error);
            });
        } catch (error) {
            handleError(ERROR_TYPES.AUDIO, 'Failed to initialize waveform', error);
        }
    }

    function updateRecorderUI() {
        const hasRecording = wavesurfer && wavesurfer.getDuration() > 0;
        
        recordBtn.disabled = false;
        stopBtn.disabled = !isRecording && !isPaused;
        playBtn.disabled = isRecording || !hasRecording;
        rewindBtn.disabled = isRecording || !hasRecording;
        forwardBtn.disabled = isRecording || !hasRecording;
        insertModeBtn.disabled = isRecording;
        overwriteModeBtn.disabled = isRecording;

        if (isRecording) {
            recordBtn.textContent = '‚è∏Ô∏è';
            recordBtn.classList.add('recording');
        } else {
            recordBtn.textContent = 'üé§';
            recordBtn.classList.remove('recording');
        }
    }
    
    async function toggleRecording() {
        try {
            if (isRecording) {
                pauseRecording();
            } else if (isPaused) {
                resumeRecording();
            } else {
                await startRecording();
            }
            updateRecorderUI();
        } catch (error) {
            handleError(ERROR_TYPES.AUDIO, 'Recording toggle failed', error);
            resetRecordingState();
        }
    }

    function pauseRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.pause();
            isPaused = true;
            isRecording = false;
        }
    }

    function resumeRecording() {
        if (mediaRecorder && mediaRecorder.state === 'paused') {
            mediaRecorder.resume();
            isPaused = false;
            isRecording = true;
        }
    }

    async function startRecording() {
        try {
            // iOS-specific constraints
            const audioConstraints = {
                sampleRate: CONFIG.AUDIO_CONSTRAINTS.sampleRate,
                channelCount: CONFIG.AUDIO_CONSTRAINTS.channels,
                echoCancellation: true,
                noiseSuppression: true
            };
            
            // iOS Safari has stricter requirements
            if (isIOSSafari) {
                // Simplified constraints for iOS Safari
                delete audioConstraints.sampleRate; // Let iOS choose optimal sample rate
                audioConstraints.autoGainControl = false; // Disable AGC which can cause issues
            }
            
            // Request microphone access
            stream = await navigator.mediaDevices.getUserMedia({ 
                audio: audioConstraints
            });
            
            const insertionTime = wavesurfer.getCurrentTime();
            let recordingStream = stream;

            // Handle audio editing if there's existing content
            // Simplified for iOS to avoid complex Web Audio operations
            if (originalBuffer && insertionTime > 0 && !isIOSSafari) {
                recordingStream = await prepareEditingStream(stream, insertionTime);
            }

            // Initialize MediaRecorder with iOS-compatible options
            mediaRecorder = createMediaRecorder(recordingStream);
            audioChunks = [];
            
            mediaRecorder.start();
            isRecording = true;
            isPaused = false;
            startSound.play().catch(() => {}); // Ignore sound errors
            
        } catch (error) {
            if (error.name === 'NotAllowedError') {
                handleError(ERROR_TYPES.PERMISSION, 'Microphone access denied', error);
            } else if (error.name === 'NotFoundError') {
                handleError(ERROR_TYPES.AUDIO, 'No microphone found', error);
            } else {
                handleError(ERROR_TYPES.AUDIO, 'Failed to start recording', error);
            }
            resetRecordingState();
        }
    }

    async function prepareEditingStream(micStream, insertionTime) {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const preSlice = sliceAudioBuffer(originalBuffer, 0, insertionTime);
            
            // Create a source for the existing audio part
            const sourceNode = audioContext.createBufferSource();
            sourceNode.buffer = preSlice;

            const mediaStreamDestination = audioContext.createMediaStreamDestination();
            sourceNode.connect(mediaStreamDestination);
            sourceNode.start();

            // Merge with microphone stream
            const micSource = audioContext.createMediaStreamSource(micStream);
            micSource.connect(mediaStreamDestination);

            return mediaStreamDestination.stream;
        } catch (error) {
            console.warn('Failed to prepare editing stream, using direct recording:', error);
            return micStream;
        }
    }

    function createMediaRecorder(stream) {
        // iOS-compatible MediaRecorder options
        let options = {
            audioBitsPerSecond: 128000
        };

        // Try different MIME types based on iOS compatibility
        const mimeTypes = [
            'audio/webm;codecs=opus',    // Preferred
            'audio/mp4;codecs=mp4a.40.2', // iOS fallback
            'audio/webm',                // Basic webm
            'audio/mp4'                  // Basic mp4
        ];

        // Find first supported MIME type
        for (const mimeType of mimeTypes) {
            if (MediaRecorder.isTypeSupported(mimeType)) {
                options.mimeType = mimeType;
                break;
            }
        }

        // iOS Safari may not support high bitrates
        if (isIOSSafari) {
            options.audioBitsPerSecond = 64000; // Lower bitrate for iOS
        }

        const recorder = new MediaRecorder(stream, options);
        
        recorder.ondataavailable = event => {
            if (event.data.size > 0) {
                audioChunks.push(event.data);
            }
        };
        
        recorder.onstop = () => processFinishedRecording();
        
        recorder.onerror = (event) => {
            handleError(ERROR_TYPES.AUDIO, 'MediaRecorder error', event.error);
            resetRecordingState();
        };

        return recorder;
    }

    function stopRecording() {
        try {
            if (mediaRecorder && (isRecording || isPaused)) {
                mediaRecorder.stop();
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                isRecording = false;
                isPaused = false;
                stopSound.play().catch(() => {});
            }
        } catch (error) {
            handleError(ERROR_TYPES.AUDIO, 'Failed to stop recording', error);
        } finally {
            updateRecorderUI();
        }
    }

    function resetRecordingState() {
        isRecording = false;
        isPaused = false;
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        updateRecorderUI();
    }
    
    async function processFinishedRecording() {
        try {
            if (audioChunks.length === 0) {
                throw new Error('No audio data recorded');
            }

            const recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const arrayBuffer = await recordedBlob.arrayBuffer();
            const newRecordingBuffer = await audioContext.decodeAudioData(arrayBuffer);

            const finalBuffer = await processAudioEditing(newRecordingBuffer);
            
            // Load the final buffer into wavesurfer
            wavesurfer.loadDecodedData(finalBuffer);
            currentFile = new Blob([]); // Placeholder - will be converted to WAV on send
            
        } catch (error) {
            handleError(ERROR_TYPES.AUDIO, 'Failed to process recording', error);
        } finally {
            updateProcessButtonState();
            resetRecordingState();
        }
    }

    async function processAudioEditing(newRecordingBuffer) {
        const insertionTime = wavesurfer.getCurrentTime();
        
        if (!originalBuffer || insertionTime === 0) {
            return newRecordingBuffer;
        }

        try {
            const preSlice = sliceAudioBuffer(originalBuffer, 0, insertionTime);

            if (editMode === 'insert') {
                const postSlice = sliceAudioBuffer(originalBuffer, insertionTime, originalBuffer.duration);
                return concatAudioBuffers([preSlice, newRecordingBuffer, postSlice]);
            } else { // Overwrite mode
                const newEndTime = insertionTime + newRecordingBuffer.duration;
                if (newEndTime < originalBuffer.duration) {
                    const postSlice = sliceAudioBuffer(originalBuffer, newEndTime, originalBuffer.duration);
                    return concatAudioBuffers([preSlice, newRecordingBuffer, postSlice]);
                } else {
                    return concatAudioBuffers([preSlice, newRecordingBuffer]);
                }
            }
        } catch (error) {
            console.warn('Audio editing failed, using new recording only:', error);
            return newRecordingBuffer;
        }
    }
    
    // --- Improved Audio Buffer Manipulation ---
    function validateAudioBuffer(buffer) {
        if (!buffer || !buffer.sampleRate || !buffer.numberOfChannels || buffer.length === 0) {
            throw new Error('Invalid audio buffer');
        }
        return true;
    }

    function sliceAudioBuffer(buffer, start, end) {
        try {
            validateAudioBuffer(buffer);
            
            if (start < 0) start = 0;
            if (end > buffer.duration) end = buffer.duration;
            if (start >= end) throw new Error('Invalid slice parameters');

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const rate = buffer.sampleRate;
            const startOffset = Math.max(0, Math.round(rate * start));
            const endOffset = Math.min(buffer.length, Math.round(rate * end));
            const frameCount = endOffset - startOffset;
            
            if (frameCount <= 0) {
                return audioContext.createBuffer(buffer.numberOfChannels, 1, rate);
            }

            const newBuffer = audioContext.createBuffer(buffer.numberOfChannels, frameCount, rate);
            
            for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                const slicedData = channelData.slice(startOffset, endOffset);
                newBuffer.copyToChannel(slicedData, channel);
            }
            
            return newBuffer;
        } catch (error) {
            console.error('Audio buffer slicing failed:', error);
            throw error;
        }
    }

    function concatAudioBuffers(buffers) {
        try {
            if (!buffers || buffers.length === 0) {
                throw new Error('No buffers to concatenate');
            }

            // Validate all buffers
            buffers.forEach((buffer, index) => {
                if (!validateAudioBuffer(buffer)) {
                    throw new Error(`Invalid buffer at index ${index}`);
                }
            });

            const firstBuffer = buffers[0];
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Check that all buffers have the same sample rate and channel count
            const sampleRate = firstBuffer.sampleRate;
            const numberOfChannels = firstBuffer.numberOfChannels;
            
            for (const buffer of buffers) {
                if (buffer.sampleRate !== sampleRate) {
                    console.warn('Sample rate mismatch in concatenation');
                }
                if (buffer.numberOfChannels !== numberOfChannels) {
                    console.warn('Channel count mismatch in concatenation');
                }
            }

            const totalLength = buffers.reduce((acc, buffer) => acc + buffer.length, 0);
            const result = audioContext.createBuffer(numberOfChannels, totalLength, sampleRate);

            let offset = 0;
            for (const buffer of buffers) {
                for (let channel = 0; channel < Math.min(numberOfChannels, buffer.numberOfChannels); channel++) {
                    const targetChannelData = result.getChannelData(channel);
                    const sourceChannelData = buffer.getChannelData(channel);
                    targetChannelData.set(sourceChannelData, offset);
                }
                offset += buffer.length;
            }
            
            return result;
        } catch (error) {
            console.error('Audio buffer concatenation failed:', error);
            throw error;
        }
    }

    function updateTimeline(current, total) {
        const formatTime = (time) => {
            if (!time || isNaN(time)) time = 0;
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            const milliseconds = Math.floor((time % 1) * 10);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds}`;
        };
        
        timeline.textContent = `${formatTime(current)} / ${formatTime(total)}`;
    }
    
    // --- Enhanced WAV Conversion with Validation ---
    async function audioBufferToWav(buffer) {
        try {
            validateAudioBuffer(buffer);
            
            const targetSampleRate = CONFIG.AUDIO_CONSTRAINTS.sampleRate;
            const numChannels = CONFIG.AUDIO_CONSTRAINTS.channels;
            
            // Resample if necessary
            let processedBuffer = buffer;
            if (buffer.sampleRate !== targetSampleRate || buffer.numberOfChannels !== numChannels) {
                processedBuffer = await resampleAudioBuffer(buffer, targetSampleRate, numChannels);
            }
            
            // Get PCM data and encode to 16-bit
            const pcmData = processedBuffer.getChannelData(0);
            const dataView = encodePCMToInt16(pcmData);
            
            // Create WAV file
            const wavBuffer = createWavFile(dataView, targetSampleRate, numChannels);
            return new Blob([wavBuffer], { type: 'audio/wav' });
            
        } catch (error) {
            handleError(ERROR_TYPES.AUDIO, 'WAV conversion failed', error);
            throw error;
        }
    }

    async function resampleAudioBuffer(buffer, targetSampleRate, targetChannels) {
        try {
            const offlineContext = new OfflineAudioContext(
                targetChannels,
                Math.ceil(buffer.duration * targetSampleRate),
                targetSampleRate
            );
            
            const bufferSource = offlineContext.createBufferSource();
            bufferSource.buffer = buffer;
            bufferSource.connect(offlineContext.destination);
            bufferSource.start();
            
            return await offlineContext.startRendering();
        } catch (error) {
            console.error('Audio resampling failed:', error);
            throw error;
        }
    }
    
    function encodePCMToInt16(samples) {
        try {
            if (!samples || samples.length === 0) {
                throw new Error('No PCM samples to encode');
            }

            const buffer = new ArrayBuffer(samples.length * 2);
            const view = new DataView(buffer);
            
            for (let i = 0; i < samples.length; i++) {
                // Clamp sample to [-1, 1] range
                let sample = Math.max(-1, Math.min(1, samples[i]));
                
                // Convert to 16-bit signed integer
                const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(i * 2, Math.round(intSample), true);
            }
            
            return view;
        } catch (error) {
            console.error('PCM encoding failed:', error);
            throw error;
        }
    }
    
    function createWavFile(dataView, sampleRate, numChannels) {
        try {
            if (!dataView || !sampleRate || !numChannels) {
                throw new Error('Invalid WAV parameters');
            }

            const dataLength = dataView.byteLength;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            // WAV file header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            
            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // chunk size
            view.setUint16(20, 1, true);  // PCM format
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2 * numChannels, true); // byte rate
            view.setUint16(32, numChannels * 2, true); // block align
            view.setUint16(34, 16, true); // bits per sample
            
            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            // Write PCM data
            new Uint8Array(buffer, 44).set(new Uint8Array(dataView.buffer));
            
            return view;
        } catch (error) {
            console.error('WAV file creation failed:', error);
            throw error;
        }
    }
    
    function writeString(view, offset, string) {
        try {
            if (!view || offset < 0 || !string) {
                throw new Error('Invalid string write parameters');
            }

            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        } catch (error) {
            console.error('String writing failed:', error);
            throw error;
        }
    }

    // --- Event Listeners Setup ---
    function setupEventListeners() {
        try {
            setupTabListeners();
            setupUploadListeners();
            setupRecorderListeners();
            setupActionListeners();
        } catch (error) {
            handleError(ERROR_TYPES.PROCESSING, 'Failed to setup event listeners', error);
        }
    }

    function setupTabListeners() {
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                try {
                    const tabId = button.dataset.tab;
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                    button.classList.add('active');
                    document.getElementById(tabId).classList.add('active');
                } catch (error) {
                    console.error('Tab switching failed:', error);
                }
            });
        });
    }

    function setupUploadListeners() {
        // Drag and drop
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.add('dragover');
        });
        
        dropzone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
        });
        
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropzone.classList.remove('dragover');
            
            if (e.dataTransfer.files.length > 0) {
                handleFileSelect(e.dataTransfer.files[0]);
            }
        });
        
        browseBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });
    }

    function setupRecorderListeners() {
        recordBtn.addEventListener('click', () => {
            toggleRecording();
            clickSound.play().catch(() => {});
        });
        
        stopBtn.addEventListener('click', () => stopRecording());
        
        playBtn.addEventListener('click', () => {
            try {
                wavesurfer.playPause();
                playBtn.textContent = wavesurfer.isPlaying() ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                clickSound.play().catch(() => {});
            } catch (error) {
                handleError(ERROR_TYPES.AUDIO, 'Playback failed', error);
            }
        });
        
        rewindBtn.addEventListener('click', () => {
            try {
                wavesurfer.skip(-3);
                clickSound.play().catch(() => {});
            } catch (error) {
                console.error('Rewind failed:', error);
            }
        });
        
        forwardBtn.addEventListener('click', () => {
            try {
                wavesurfer.skip(3);
                clickSound.play().catch(() => {});
            } catch (error) {
                console.error('Forward failed:', error);
            }
        });
        
        insertModeBtn.addEventListener('click', () => setEditMode('insert'));
        overwriteModeBtn.addEventListener('click', () => setEditMode('overwrite'));
    }

    function setEditMode(mode) {
        editMode = mode;
        insertModeBtn.classList.toggle('active', mode === 'insert');
        overwriteModeBtn.classList.toggle('active', mode === 'overwrite');
        clickSound.play().catch(() => {});
    }

    function setupActionListeners() {
        processBtn.addEventListener('click', processAndSendAudio);
        newSessionBtn.addEventListener('click', resetToStart);
        copyBtn.addEventListener('click', copyFormattedText);
        saveBtn.addEventListener('click', saveTextToFile);
    }
    
    // --- Text Formatting & Output ---
    function formatTextAsHtml(text) {
        if (!text) return "";
        
        try {
            const lines = text.split('\n');
            const formattedLines = lines.map(line => {
                let processedLine = line.trim();
                const boldStyle = 'font-weight:bold;';
                
                // Replace **text** with bold spans
                processedLine = processedLine.replace(/\*\*(.*?)\*\*/g, `<span style="${boldStyle}">$1</span>`);
                
                // Make all-caps lines bold if not already formatted
                if (!processedLine.includes(boldStyle) && processedLine.length > 0 && processedLine === processedLine.toUpperCase()) {
                    processedLine = `<span style="${boldStyle}">${processedLine}</span>`;
                }
                
                return processedLine;
            });
            
            return formattedLines.join('<br>');
        } catch (error) {
            console.error('Text formatting failed:', error);
            return text; // Return original text if formatting fails
        }
    }
    
    function copyFormattedText() {
        try {
            const htmlContent = resultText.innerHTML;
            const wordCompatibleHtml = htmlContent.replace(/<br\s*\/?>/gi, '</p><p>');
            const styledHtml = `
                <html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">
                <head><meta charset="utf-8"><style>p { margin: 0; font-family: Arial, sans-serif; font-size: 11pt; line-height: 1.5; } span[style*="font-weight:bold"] { font-weight: bold !important; }</style></head>
                <body><p>${wordCompatibleHtml}</p></body>
                </html>`;
            const plainText = resultText.innerText;
            
            if (navigator.clipboard && navigator.clipboard.write) {
                const htmlBlob = new Blob([styledHtml], { type: 'text/html' });
                const textBlob = new Blob([plainText], { type: 'text/plain' });
                const clipboardItem = new ClipboardItem({ 'text/html': htmlBlob, 'text/plain': textBlob });
                
                navigator.clipboard.write([clipboardItem])
                    .then(() => alert("Rapport copi√© dans le presse-papiers avec formatage !"))
                    .catch(err => {
                        console.error("Modern clipboard failed:", err);
                        fallbackCopy(styledHtml, plainText);
                    });
            } else {
                fallbackCopy(styledHtml, plainText);
            }
        } catch (error) {
            handleError(ERROR_TYPES.PROCESSING, 'Copy failed', error);
        }
    }

    function fallbackCopy(htmlContent, plainText) {
        try {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            document.body.appendChild(tempDiv);
            
            const range = document.createRange();
            range.selectNodeContents(tempDiv);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            
            const copySuccess = document.execCommand('copy');
            document.body.removeChild(tempDiv);
            selection.removeAllRanges();
            
            if (copySuccess) {
                alert("Rapport copi√© dans le presse-papiers avec formatage !");
            } else {
                // Final fallback to plain text
                navigator.clipboard.writeText(plainText)
                    .then(() => alert("Rapport copi√© (texte brut uniquement)"))
                    .catch(() => alert("√âchec de la copie du rapport"));
            }
        } catch (error) {
            console.error('Fallback copy failed:', error);
            alert("√âchec de la copie du rapport");
        }
    }
    
    function saveTextToFile() {
        try {
            const text = resultText.innerText;
            if (!text) {
                alert("Aucun texte √† sauvegarder");
                return;
            }

            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `radiology_report_${Date.now()}.txt`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(link.href);
        } catch (error) {
            handleError(ERROR_TYPES.PROCESSING, 'File save failed', error);
        }
    }
});
</script>

</body>
</html>
